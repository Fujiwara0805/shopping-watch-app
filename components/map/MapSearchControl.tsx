"use client";

import React, { useState, useRef, useEffect } from 'react';
import { motion } from 'framer-motion';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { Search, X, MapPin as PinIcon, Navigation } from 'lucide-react';
import { useGoogleMapsApi } from '@/components/providers/GoogleMapsApiProvider';

interface MapSearchControlProps {
  map: google.maps.Map | null;
  userLocation: google.maps.LatLng | null;
  onPlaceSelected: (
    place: google.maps.places.PlaceResult,
    distance: string | null
  ) => void;
  onSearchError?: (error: string) => void;
  className?: string;
  initialValue?: string;
}

export function MapSearchControl({
  map,
  userLocation,
  onPlaceSelected,
  onSearchError,
  className,
  initialValue = '',
}: MapSearchControlProps) {
  const { isLoaded: isMapsApiLoaded, loadError } = useGoogleMapsApi();
  const inputRef = useRef<HTMLInputElement>(null);
  const autocompleteRef = useRef<google.maps.places.Autocomplete | null>(null);
  const [inputValue, setInputValue] = useState(initialValue);
  const [isFocused, setIsFocused] = useState(false);
  // üî• ‰øÆÊ≠£1: ÂàùÊúüÊ§úÁ¥¢„ÅÆÂÆüË°å„ÇíËøΩË∑°„Åô„Çã„Éï„É©„Ç∞„ÇíËøΩÂä†
  const initialSearchExecutedRef = useRef(false);

  // ÂàùÊúüÂÄ§„ÅåÂ§âÊõ¥„Åï„Çå„ÅüÊôÇ„Å´ÂÖ•ÂäõÂÄ§„ÇíÊõ¥Êñ∞
  useEffect(() => {
    setInputValue(initialValue);
    if (inputRef.current) {
      inputRef.current.value = initialValue;
    }
    // üî• ‰øÆÊ≠£2: ÂàùÊúüÂÄ§„ÅåÂ§âÊõ¥„Åï„Çå„Åü„ÇâÊ§úÁ¥¢„Éï„É©„Ç∞„Çí„É™„Çª„ÉÉ„Éà
    initialSearchExecutedRef.current = false;
  }, [initialValue]);

  useEffect(() => {
    // APIË™≠„ÅøËæº„Åø„Ç®„É©„Éº„Åæ„Åü„ÅØÂú∞Âõ≥„ÅåÊú™ÂàùÊúüÂåñ„ÅÆÂ†¥Âêà„ÅØ„Çπ„Ç≠„ÉÉ„Éó
    if (!isMapsApiLoaded || !inputRef.current || !map || loadError) {
      console.log("MapSearchControl: Skipping autocomplete setup", {
        isMapsApiLoaded,
        hasInput: !!inputRef.current,
        hasMap: !!map,
        loadError: !!loadError
      });
      
      // Êó¢Â≠ò„ÅÆ„Ç™„Éº„Éà„Ç≥„É≥„Éó„É™„Éº„Éà„Çí„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
      if (autocompleteRef.current && typeof google !== 'undefined' && google.maps && google.maps.event) {
         google.maps.event.clearInstanceListeners(autocompleteRef.current);
         autocompleteRef.current = null;
      }
      return;
    }
    
    console.log("MapSearchControl: Setting up autocomplete");
    
    // Êó¢Â≠ò„ÅÆ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº„Çí„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
    if (autocompleteRef.current && typeof google !== 'undefined' && google.maps && google.maps.event) {
        google.maps.event.clearInstanceListeners(autocompleteRef.current);
    }

    const autocompleteOptions: google.maps.places.AutocompleteOptions = {
      types: ['establishment', 'geocode'],
      componentRestrictions: { country: 'jp' },
      fields: ['place_id', 'name', 'formatted_address', 'geometry', 'types', 'photos'],
    };

    // Âú∞Âõ≥„ÅÆÂ¢ÉÁïå„ÇíË®≠ÂÆö
    if (map.getBounds()) {
      autocompleteOptions.bounds = map.getBounds() as google.maps.LatLngBounds;
      autocompleteOptions.strictBounds = false;
    }
    
    // „É¶„Éº„Ç∂„Éº‰ΩçÁΩÆ„Çí‰∏≠ÂøÉ„Å®„Åó„ÅüÂ¢ÉÁïå„ÇíË®≠ÂÆö
    if (userLocation) {
        const circle = new google.maps.Circle({
            center: userLocation,
            radius: 50000, // 50km
        });
        autocompleteOptions.bounds = circle.getBounds() as google.maps.LatLngBounds;
    }

    try {
      if (inputRef.current) {
          const newAutocomplete = new window.google.maps.places.Autocomplete(
            inputRef.current,
            autocompleteOptions
          );

          // üî• Ê§úÁ¥¢ÂÄôË£ú„ÅÆ„Ç´„Çπ„Çø„É†Ë°®Á§∫„Éï„Ç©„Éº„Éû„ÉÉ„Éà
          const formatSearchResults = () => {
            setTimeout(() => {
              const pacContainer = document.querySelector('.pac-container') as HTMLElement;
              if (pacContainer) {
                const pacItems = pacContainer.querySelectorAll('.pac-item');
                
                pacItems.forEach((item) => {
                  const pacItemQuery = item.querySelector('.pac-item-query');
                  if (pacItemQuery) {
                    // Â∫óËàóÂêç„Å®‰ΩèÊâÄ„ÇíÂàÜÈõ¢
                    const fullText = pacItemQuery.textContent || '';
                    const parts = fullText.split(',');
                    
                    if (parts.length >= 2) {
                      const storeName = parts[0].trim();
                      const address = parts.slice(1).join(',').trim();
                      
                      // HTML„ÇíÂÜçÊßãÁØâ
                      pacItemQuery.innerHTML = `
                        <div style="font-weight: 600; font-size: 16px; color: #1f2937; margin-bottom: 4px; line-height: 1.2; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                          ${storeName}
                        </div>
                        <div style="font-size: 13px; color: #6b7280; font-weight: 400; line-height: 1.3; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                          ${address}
                        </div>
                      `;
                    }
                  }
                });
                
                // „Éâ„É≠„ÉÉ„Éó„ÉÄ„Ç¶„É≥„Åå„ÇØ„É™„ÉÉ„ÇØ„Åï„Çå„ÅüÊôÇ„Å´„Éï„Ç©„Éº„Ç´„Çπ„ÇíÁ∂≠ÊåÅ
                pacContainer.addEventListener('mousedown', (e) => {
                  e.preventDefault(); // „Éá„Éï„Ç©„É´„Éà„ÅÆ„Éñ„É©„ÉºÂãï‰Ωú„ÇíÈò≤„Åê
                });
              }
            }, 100);
          };

          // ÂÖ•Âäõ„Ç§„Éô„É≥„Éà„Åß„Éï„Ç©„Éº„Éû„ÉÉ„Éà„ÇíÈÅ©Áî®
          if (inputRef.current) {
            inputRef.current.addEventListener('input', formatSearchResults);
          }

          newAutocomplete.addListener('place_changed', () => {
            const place = newAutocomplete.getPlace();
            console.log("MapSearchControl: Place selected:", place);
            
            if (place && place.geometry && (place.name || place.formatted_address)) {
              // Ë°®Á§∫Âêç„ÇíÊ±∫ÂÆöÔºàname„ÅåÂÑ™ÂÖà„ÄÅ„Å™„Åë„Çå„Å∞formatted_addressÔºâ
              const displayName = place.name || place.formatted_address || '';
              
              // React„ÅÆÁä∂ÊÖã„ÇíÊõ¥Êñ∞
              setInputValue(displayName);
              
              // ÂÖ•Âäõ„Éï„Ç£„Éº„É´„Éâ„ÅÆÂÄ§„ÇÇÁõ¥Êé•Êõ¥Êñ∞ÔºàGoogle Maps API„Å®„ÅÆÂêåÊúü„ÅÆ„Åü„ÇÅÔºâ
              if (inputRef.current) {
                inputRef.current.value = displayName;
              }
              
              let distanceText: string | null = null;
              
              // Ë∑ùÈõ¢Ë®àÁÆó
              if (userLocation && place.geometry.location) {
                const distance = google.maps.geometry.spherical.computeDistanceBetween(
                  userLocation,
                  place.geometry.location
                );
                distanceText = (distance / 1000).toFixed(1) + ' km';
              }
              
              // Â∞ë„ÅóÈÅÖÂª∂„ÇíÂÖ•„Çå„Å¶„Åã„ÇâÂá¶ÁêÜ„ÇíÂÆüË°åÔºàUI„ÅÆÊõ¥Êñ∞„ÇíÁ¢∫ÂÆü„Å´„Åô„Çã„Åü„ÇÅÔºâ
              setTimeout(() => {
                onPlaceSelected(place, distanceText);
                // „Éï„Ç©„Éº„Ç´„ÇπÁä∂ÊÖã„Çí„É™„Çª„ÉÉ„Éà
                setIsFocused(false);
                inputRef.current?.blur();
              }, 100);
            } else {
              console.warn("MapSearchControl: Invalid place selected:", place);
              if (onSearchError) {
                onSearchError("ÊúâÂäπ„Å™Â†¥ÊâÄ„ÅåÈÅ∏Êäû„Åï„Çå„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ");
              }
            }
          });
          
          autocompleteRef.current = newAutocomplete;
          console.log("MapSearchControl: Autocomplete setup completed");
      }
    } catch (error) {
      console.error("MapSearchControl: Error setting up autocomplete:", error);
      if (onSearchError) {
        onSearchError("Ê§úÁ¥¢Ê©üËÉΩ„ÅÆÂàùÊúüÂåñ„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ");
      }
    }
    
    return () => {
        if (autocompleteRef.current && typeof google !== 'undefined' && google.maps && google.maps.event) {
            google.maps.event.clearInstanceListeners(autocompleteRef.current);
        }
    };
  }, [isMapsApiLoaded, map, userLocation, onPlaceSelected, onSearchError, loadError]); // üî• ‰øÆÊ≠£3: initialValue„Çí‰æùÂ≠òÈÖçÂàó„Åã„ÇâÂâäÈô§

  // üî• ‰øÆÊ≠£4: ÂàùÊúüÊ§úÁ¥¢„ÇíÂà•„ÅÆuseEffect„Å´ÂàÜÈõ¢
  useEffect(() => {
    // ÂàùÊúüÂÄ§„Åå„ÅÇ„ÇãÂ†¥Âêà„ÄÅËá™ÂãïÊ§úÁ¥¢„ÇíÂÆüË°åÔºà‰∏ÄÂ∫¶„Å†„ÅëÔºâ
    if (initialValue && 
        initialValue.trim() && 
        !initialSearchExecutedRef.current && 
        isMapsApiLoaded && 
        map && 
        !loadError) {
      
      console.log("MapSearchControl: Triggering initial search for:", initialValue);
      initialSearchExecutedRef.current = true; // ÂÆüË°åÊ∏à„Åø„Éï„É©„Ç∞„ÇíË®≠ÂÆö
      
      // Places API„ÅÆTextSearch„Çí‰ΩøÁî®„Åó„Å¶ÂàùÊúüÊ§úÁ¥¢„ÇíÂÆüË°å
      const service = new google.maps.places.PlacesService(map);
      const request = {
        query: initialValue,
        location: userLocation || undefined,
        radius: userLocation ? 50000 : undefined,
        type: 'establishment'
      };
      
      service.textSearch(request, (results, status) => {
        if (status === google.maps.places.PlacesServiceStatus.OK && results && results[0]) {
          const place = results[0];
          console.log("MapSearchControl: Initial search result:", place);
          
          let distanceText: string | null = null;
          if (userLocation && place.geometry?.location) {
            const distance = google.maps.geometry.spherical.computeDistanceBetween(
              userLocation,
              place.geometry.location
            );
            distanceText = (distance / 1000).toFixed(1) + ' km';
          }
          
          onPlaceSelected(place, distanceText);
        } else {
          console.log("MapSearchControl: Initial search failed or no results");
        }
      });
    }
  }, [initialValue, isMapsApiLoaded, map, loadError, userLocation, onPlaceSelected]);

  const handleClearInput = () => {
    setInputValue('');
    if (inputRef.current) {
      inputRef.current.value = '';
      inputRef.current.focus();
    }
  };
  
  const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const newValue = event.target.value;
    setInputValue(newValue);
    
    // Google Maps API„ÅÆÂÖ•Âäõ„Éï„Ç£„Éº„É´„Éâ„Å®„ÇÇÂêåÊúü
    if (inputRef.current && inputRef.current.value !== newValue) {
      inputRef.current.value = newValue;
    }
  };

  // üî• ‰øÆÊ≠£5: „Çø„ÉÉ„ÉÅ„Ç§„Éô„É≥„Éà„ÅÆÂïèÈ°å„ÇíËß£Ê±∫„Åô„Çã„Åü„ÇÅ„Å´passive option„ÇíËøΩÂä†
  const handleFocus = () => setIsFocused(true);
  
  const handleBlur = (event: React.FocusEvent<HTMLInputElement>) => {
    // Google Places „Éâ„É≠„ÉÉ„Éó„ÉÄ„Ç¶„É≥ÂÜÖ„ÅÆË¶ÅÁ¥†„Å´„Éï„Ç©„Éº„Ç´„Çπ„ÅåÁßª„Å£„ÅüÂ†¥Âêà„ÅØÁÑ°Ë¶ñ
    const relatedTarget = event.relatedTarget as HTMLElement;
    if (relatedTarget && relatedTarget.closest('.pac-container')) {
      return;
    }
    
    // „Éñ„É©„ÉºÊôÇ„Å´ÈÅÖÂª∂„ÇíÂÖ•„Çå„ÇãÔºà„Ç™„Éº„Éà„Ç≥„É≥„Éó„É™„Éº„Éà„ÅÆÈÅ∏Êäû„ÇíÂ¶®„Åí„Å™„ÅÑ„Åü„ÇÅÔºâ
    setTimeout(() => {
      // „Éâ„É≠„ÉÉ„Éó„ÉÄ„Ç¶„É≥„ÅåË°®Á§∫„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà„ÅØ„ÄÅ„Éï„Ç©„Éº„Ç´„ÇπÁä∂ÊÖã„ÇíÁ∂≠ÊåÅ
      const pacContainers = document.querySelectorAll('.pac-container');
      const hasVisibleDropdown = Array.from(pacContainers).some(
        container => (container as HTMLElement).style.display !== 'none'
      );
      
      if (!hasVisibleDropdown) {
        setIsFocused(false);
      }
    }, 200); // ÈÅÖÂª∂„Çí200ms„Å´Â¢óÂä†
  };

  if (loadError) {
    console.error("MapSearchControl: Google Maps API load error:", loadError);
    return (
        <div className={`p-4 text-center text-sm text-red-400 ${className}`}>
            <div className="flex items-center justify-center gap-2">
                <div className="w-2 h-2 bg-red-400 rounded-full animate-pulse"></div>
                Ê§úÁ¥¢Ê©üËÉΩ„ÅÆË™≠„ÅøËæº„Åø„Å´Â§±Êïó„Åó„Åæ„Åó„Åü
            </div>
        </div>
    );
  }

  if (!isMapsApiLoaded) {
     return (
        <div className={`p-4 text-center text-sm ${className}`}>
            <div 
                className="flex items-center justify-center gap-2"
                style={{ color: '#73370c' }}
            >
                <div 
                    className="w-2 h-2 rounded-full animate-pulse"
                    style={{ backgroundColor: '#73370c' }}
                ></div>
                Ê§úÁ¥¢Ê©üËÉΩ„ÇíË™≠„ÅøËæº„Åø‰∏≠...
            </div>
        </div>
    );
  }

  return (
    <motion.div
      className={`relative w-full ${className || ''}`}
      initial={{ y: -20, opacity: 0, scale: 0.95 }}
      animate={{ y: 0, opacity: 1, scale: 1 }}
      transition={{ duration: 0.4, ease: "easeOut" }}
    >
      <motion.div 
        className="relative overflow-hidden rounded-2xl shadow-2xl"
        style={{
          background: `linear-gradient(135deg, #73370c 0%, #8b4513 50%, #73370c 100%)`,
          boxShadow: isFocused 
            ? '0 20px 40px rgba(115, 55, 12, 0.3), 0 0 0 2px rgba(115, 55, 12, 0.2)' 
            : '0 10px 30px rgba(115, 55, 12, 0.2)'
        }}
        animate={{
          scale: isFocused ? 1.02 : 1,
        }}
        transition={{ duration: 0.2, ease: "easeInOut" }}
      >
        {/* „Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥„Ç™„Éº„Éê„Éº„É¨„Ç§ */}
        <div 
          className="absolute inset-0 opacity-20"
          style={{
            background: 'linear-gradient(45deg, rgba(255,255,255,0.1) 0%, transparent 50%, rgba(255,255,255,0.1) 100%)'
          }}
        />
        
        <div className="relative flex items-center p-3">
          {/* Ê§úÁ¥¢„Ç¢„Ç§„Ç≥„É≥ */}
          <motion.div
            animate={{
              rotate: isFocused ? 360 : 0,
              scale: isFocused ? 1.1 : 1
            }}
            transition={{ duration: 0.3, ease: "easeInOut" }}
            className="flex-shrink-0 ml-2"
          >
            <Search 
              className="h-6 w-6" 
              style={{ color: 'rgba(255, 255, 255, 0.9)' }}
            />
          </motion.div>

          {/* ÂÖ•Âäõ„Éï„Ç£„Éº„É´„Éâ */}
          <Input
            ref={inputRef}
            type="text"
            placeholder="„ÅäÂ∫ó„ÇÑ„Ç≠„Éº„ÉØ„Éº„Éâ„ÇíÊ§úÁ¥¢"
            value={inputValue}
            onChange={handleInputChange}
            onFocus={handleFocus}
            onBlur={handleBlur}
            className="flex-grow bg-transparent border-none focus-visible:ring-0 focus-visible:ring-offset-0 text-white placeholder:text-white/70 text-base font-medium pl-4 pr-12 py-3 h-auto"
            style={{
              caretColor: 'white',
              textShadow: '0 1px 2px rgba(0,0,0,0.2)',
              fontSize: '18px' // „É¢„Éê„Ç§„É´„Åß„ÅÆ„Ç∫„Éº„É†ÁÑ°ÂäπÂåñ
            }}
            disabled={!isMapsApiLoaded || !map}
            autoComplete="off"
            autoCorrect="off"
            autoCapitalize="off"
            spellCheck="false"
            // üî• ‰øÆÊ≠£6: „Çø„ÉÉ„ÉÅ„Ç§„Éô„É≥„Éà„ÅÆÂïèÈ°å„ÇíËß£Ê±∫„Åô„Çã„Åü„ÇÅ„ÅÆÂ±ûÊÄß„ÇíËøΩÂä†
            onTouchStart={(e) => {
              // „Çø„ÉÉ„ÉÅ„Ç§„Éô„É≥„Éà„Çípassive„Å´„Åó„Å¶„ÄÅ„Çπ„ÇØ„É≠„Éº„É´„ÇíÂ¶®„Åí„Å™„ÅÑ„Çà„ÅÜ„Å´„Åô„Çã
              e.currentTarget.style.touchAction = 'manipulation';
            }}
          />

          {/* „ÇØ„É™„Ç¢„Éú„Çø„É≥ */}
          {inputValue && (
            <motion.div
              initial={{ opacity: 0, scale: 0, x: 10 }}
              animate={{ opacity: 1, scale: 1, x: 0 }}
              exit={{ opacity: 0, scale: 0, x: 10 }}
              transition={{ duration: 0.2, ease: "easeOut" }}
            >
              <Button
                type="button"
                variant="ghost"
                size="icon"
                className="absolute right-3 top-1/2 -translate-y-1/2 h-8 w-8 p-0 rounded-full bg-white/20 hover:bg-white/30 transition-all duration-200 backdrop-blur-sm"
                onClick={handleClearInput}
                // üî• ‰øÆÊ≠£7: „Çø„ÉÉ„ÉÅ„Ç§„Éô„É≥„Éà„ÅÆÂïèÈ°å„ÇíËß£Ê±∫
                onTouchStart={(e) => {
                  e.currentTarget.style.touchAction = 'manipulation';
                }}
              >
                <X className="h-4 w-4 text-white" />
              </Button>
            </motion.div>
          )}
        </div>

        {/* ‰∏ãÈÉ®„ÅÆ„Ç¢„ÇØ„Çª„É≥„Éà„É©„Ç§„É≥ */}
        <motion.div
          className="absolute bottom-0 left-0 h-1 bg-gradient-to-r from-transparent via-white/40 to-transparent"
          animate={{
            width: isFocused ? '100%' : '0%',
            opacity: isFocused ? 1 : 0
          }}
          transition={{ duration: 0.3, ease: "easeInOut" }}
        />
      </motion.div>

      {/* „Éï„Ç©„Éº„Ç´„ÇπÊôÇ„ÅÆ„É™„É≥„Ç∞ÂäπÊûú */}
      {isFocused && (
        <motion.div
          className="absolute inset-0 rounded-2xl pointer-events-none"
          style={{
            background: `linear-gradient(135deg, transparent 0%, rgba(115, 55, 12, 0.1) 50%, transparent 100%)`,
            boxShadow: '0 0 0 3px rgba(115, 55, 12, 0.15)'
          }}
          initial={{ opacity: 0, scale: 0.95 }}
          animate={{ opacity: 1, scale: 1 }}
          exit={{ opacity: 0, scale: 0.95 }}
          transition={{ duration: 0.2 }}
        />
      )}
    </motion.div>
  );
}